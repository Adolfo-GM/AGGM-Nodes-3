<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Aggm Nodes (Extensible)</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Aggm Nodes">
<link rel="apple-touch-icon" href="icon-192x192.png">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.0/jszip.min.js"></script>
<style>
  :root {
    --bg-color: #000000;
    --node-bg: #1a1a1a;
    --node-header-bg: #333333;
    --node-border: #444444;
    --text-color: #ffffff;
    --connector-color: #ffffff;
    --connector-hover: #cccccc;
    --btn-bg: #ffffff;
    --btn-text: #000000;
    --sidebar-bg: #111111;
    --context-menu-bg: #222222;
    --context-menu-item-hover: #555555;
    --search-input-bg: #3c3c3c;
    --search-input-border: #555;
  }
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    overflow: hidden;
  }
  #app {
    display: flex;
    height: 100vh;
  }
  #sidebar {
    width: 200px;
    background-color: var(--sidebar-bg);
    padding: 15px;
    box-shadow: 3px 0 15px rgba(0,0,0,0.3);
    z-index: 10;
    display: flex;
    flex-direction: column;
  }
  #sidebar h2 {
    margin-top: 0;
    font-size: 1.2rem;
    padding-bottom: 10px;
    margin-bottom: 10px;
  }
  #search-nodes {
    width: 100%;
    padding: 8px 10px;
    margin-bottom: 15px;
    margin-top: 10px;
    background-color: var(--search-input-bg);
    border-radius: 12px;
    color: var(--text-color);
    box-sizing: border-box;
    text-align: center;
    border: none;
    border: 1px solid rgba(255, 255, 255, 0);
  }
  #search-nodes:focus {
    outline: none;
    border: 1px solid var(--search-input-border);
  }
  #node-list {
    flex-grow: 1;
    overflow-y: auto;
    margin-bottom: 15px;
  }
  .node-type {
    padding: 10px 12px;
    margin-bottom: 8px;
    background-color: var(--node-bg);
    border-radius: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  .node-type:hover {
    background-color: var(--node-header-bg);
  }
  #canvas {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
    background-color: #000000;
    background-image: radial-gradient(circle, #2a2a2a 1px, transparent 1px);
    background-size: 25px 25px;
    cursor: default;
  }
  #canvas-content-wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
  }
  #connections {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    transform-origin: 0 0;
  }
  .node {
    position: absolute;
    background-color: var(--node-bg);
    border: 1px solid var(--node-border);
    border-radius: 24px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    min-width: 180px;
    user-select: none;
    transition: box-shadow 0.2s;
  }
  .node.dragging {
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    z-index: 100;
  }
  .node-header {
    background-color: var(--node-header-bg);
    color: #fff;
    padding: 10px 14px;
    font-weight: bold;
    cursor: move;
    border-top-left-radius: 23px;
    border-top-right-radius: 23px;
  }
  .node-io {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
  }
  .inputs, .outputs {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .io-item {
    display: flex;
    align-items: center;
    padding: 0 10px;
  }
  .io-connector {
    width: 14px;
    height: 14px;
    background-color: var(--connector-color);
    border: 3px solid var(--node-bg);
    border-radius: 50%;
    cursor: crosshair;
    transition: background-color 0.2s, transform 0.2s;
  }
  .io-connector:hover {
    background-color: var(--connector-hover);
    transform: scale(1.2);
  }
  .io-connector.input {
    margin-right: -7px;
  }
  .io-connector.output {
    margin-left: -7px;
  }
  input.node-input, .node-content, textarea.node-input, select.node-input {
    background: var(--bg-color);
    color: var(--text-color);
    border: 1px solid var(--node-border);
    border-radius: 8px;
    padding: 8px;
    margin: 5px 10px 10px;
    width: calc(100% - 36px);
    box-sizing: border-box;
  }
  .node-content {
    border: none;
  }
  textarea.node-input {
    resize: vertical;
    min-height: 40px;
  }
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
  }
  input[type="range"]::-webkit-slider-runnable-track {
    background: var(--search-input-bg);
    height: 6px;
    border-radius: 3px;
  }
  input[type="range"]::-moz-range-track {
    background: var(--search-input-bg);
    height: 6px;
    border-radius: 3px;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    margin-top: -4px;
    background-color: var(--btn-bg);
    height: 14px;
    width: 14px;
    border-radius: 50%;
  }
  input[type="range"]::-moz-range-thumb {
    background-color: var(--btn-bg);
    height: 14px;
    width: 14px;
    border-radius: 50%;
    border: none;
  }
  .control-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: auto;
  }
  .control-buttons button {
    padding: 10px 15px;
    font-size: 1rem;
    font-weight: bold;
    background-color: var(--btn-bg);
    color: var(--btn-text);
    border: 1px solid var(--btn-bg);
    border-radius: 10px;
    cursor: pointer;
    box-shadow: 0 3px 8px rgba(0,0,0,0.2);
    transition: background-color 0.2s, color 0.2s, transform 0.2s;
    width: 100%;
    box-sizing: border-box;
  }
  .control-buttons button:hover {
    background-color: var(--btn-text);
    color: var(--btn-bg);
    border-color: var(--btn-bg);
    transform: translateY(-1px);
  }
  #run-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 12px 20px;
    font-size: 1.2rem;
    font-weight: bold;
    background-color: var(--btn-bg);
    color: var(--btn-text);
    border: 1px solid var(--btn-bg);
    border-radius: 12px;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    transition: background-color 0.2s, color 0.2s, transform 0.2s;
    z-index: 20;
    width: auto;
    min-width: 100px;
    text-align: center;
  }
  #run-btn:hover {
    background-color: var(--btn-text);
    color: var(--btn-bg);
    border-color: var(--btn-bg);
    transform: translateY(-2px);
  }

  #context-menu {
    position: absolute;
    background-color: var(--context-menu-bg);
    border: 1px solid var(--node-border);
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    z-index: 200;
    display: none;
    padding: 5px 0;
  }
  .context-menu-item {
    padding: 8px 15px;
    cursor: pointer;
    color: var(--text-color);
    white-space: nowrap;
  }
  .context-menu-item:hover {
    background-color: var(--context-menu-item-hover);
  }
  #top-right-controls {
    position: fixed;
    top: 15px;
    right: 20px;
    z-index: 20;
    display: flex;
    align-items: center;
    gap: 10px;
    background-color: var(--sidebar-bg);
    padding: 8px 12px;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  }
  #project-name-input {
    background-color: var(--search-input-bg);
    color: var(--text-color);
    border: 1px solid var(--node-border);
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 0.9rem;
  }
  #project-name-input:focus {
    outline: none;
    border-color: var(--search-input-border);
  }
  .top-control-btn {
    padding: 8px 12px;
    font-size: 0.9rem;
    background-color: var(--btn-bg);
    color: var(--btn-text);
    font-weight: bold;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s, color 0.2s;
  }
  .top-control-btn:hover {
    background-color: var(--btn-text);
    color: var(--btn-bg);
  }
  #node-counter {
    font-size: 0.9rem;
    color: var(--text-color);
    padding: 0 10px;
    opacity: 0.7;
  }
  .output-iframe {
      border: 1px solid var(--node-border);
      border-radius: 8px;
      width: calc(100% - 20px);
      height: 100px;
      margin: 10px;
      background: #fff;
  }
</style>
<meta name="author" content="Adolfo GM">
<meta name="description" content="Node IDE Editor - Created by Adolfo GM">
</head>
<body>

<div id="app">
  <div id="sidebar">
    <div style="display: flex; align-items: center; gap: 10px;">
      <img src="logo.png" alt="Aggm Nodes Logo" id="logo" style="height: 1.5em; width: 1.5em;"/>
      <h2 style="margin: 0; margin-top: 10px;">Aggm Nodes</h2>
    </div>
    <input type="text" id="search-nodes" placeholder="Search nodes" />
    <div id="node-list"></div>
    <div class="control-buttons">
        <input type="file" id="import-nodes-file" accept=".json,.js,.py" style="display: none;" />
        <button id="import-nodes-btn">Import</button>
        <button id="export-project-btn">Export Project</button>
        </div>
  </div>
  <div id="canvas">
    <svg id="connections" xmlns="http://www.w3.org/2000/svg" style="overflow: visible;"></svg>
    <div id="canvas-content-wrapper">
    </div>
  </div>
  
  <div id="top-right-controls">
    <span id="node-counter" title="Current node count">Nodes: 0</span>
    <input type="text" id="project-name-input" placeholder="Project Name" title="Current Project Name">
    <button id="clear-workspace-btn" class="top-control-btn" title="Clear Workspace">Clear</button>
  </div>

  <button id="run-btn" title="Run the node graph">▶ Run</button>
</div>

<div id="context-menu">
  <div class="context-menu-item" data-action="delete">Delete Node</div>
  <div class="context-menu-item" data-action="duplicate">Duplicate Node</div>
</div>

<!-- IMPORTANT: This file provides the ability to add custom nodes -->
<script src="external-nodes.js" defer></script>

<script>
// This main script will now wait for the external-nodes.js file to load
document.addEventListener('DOMContentLoaded', () => {

  const nodeTypes = {};

  const BUILTIN_NODE_DEFINITIONS = {
    NumberNode: {
      definition: {
          title: "Number",
          inputs: [],
          outputs: ["value"],
          renderContent(node) {
            if (node.value === undefined) node.value = 0;
            return `<div class="node-content"><input class="node-input number-input" type="number" value="${node.value}" /></div>`;
          },
          update(node) {
            const input = node.dom.querySelector('input.number-input');
            if (input) node.value = Number(input.value);
          },
          getOutput() { return this.value; }
      },
      jsLogic: `function() { return this.value; }`,
      pyLogic: `def get_output_number(node):\n    return node.get("value", 0)`,
      pyImports: [],
    },
    TextNode: {
      definition: {
          title: "Text",
          inputs: [],
          outputs: ["text"],
          renderContent(node) {
            if (node.value === undefined) node.value = "";
            return `<div class="node-content"><input class="node-input text-input" type="text" value="${node.value}" placeholder="Enter text..." /></div>`;
          },
          update(node) {
            const input = node.dom.querySelector('input.text-input');
            if (input) node.value = input.value;
          },
          getOutput() { return this.value; }
      },
      jsLogic: `function() { return this.value; }`,
      pyLogic: `def get_output_text(node):\n    return node.get("value", "")`,
      pyImports: [],
    },
    AddNode: {
        definition: {
          title: "Add",
          inputs: ["a", "b"],
          outputs: ["sum"],
          renderContent() { return `<div class="node-content" style="padding:10px; font-size:0.9rem;">Adds two numbers.</div>`; },
          compute(inputs) {
            const a = inputs["a"]; const b = inputs["b"];
            if (typeof a !== 'number' || typeof b !== 'number') return null;
            return a + b;
          }
        },
        jsLogic: `async function(inputs) {
            const a = inputs["a"]; const b = inputs["b"];
            if (typeof a !== 'number' || typeof b !== 'number') return null;
            return a + b;
        }`,
        pyLogic: `def compute_add(inputs):\n    a = inputs.get("a")\n    b = inputs.get("b")\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return a + b\n    return None`,
        pyImports: [],
    },
    SubtractNode: {
        definition: {
            title: "Subtract",
            inputs: ["a", "b"],
            outputs: ["difference"],
            renderContent() { return `<div class="node-content" style="padding:10px; font-size:0.9rem;">Subtracts b from a.</div>`; },
            compute(inputs) { const a = inputs["a"]; const b = inputs["b"]; if (typeof a !== 'number' || typeof b !== 'number') return null; return a - b; }
        },
        jsLogic: `async function(inputs) { const a = inputs["a"]; const b = inputs["b"]; if (typeof a !== 'number' || typeof b !== 'number') return null; return a - b; }`,
        pyLogic: `def compute_subtract(inputs):\n    a = inputs.get("a")\n    b = inputs.get("b")\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return a - b\n    return None`,
        pyImports: [],
    },
    MultiplyNode: {
        definition: {
            title: "Multiply",
            inputs: ["x", "y"],
            outputs: ["product"],
            renderContent() { return `<div class="node-content" style="padding:10px; font-size:0.9rem;">Multiplies two numbers.</div>`; },
            compute(inputs) { const x = inputs["x"]; const y = inputs["y"]; if (typeof x !== 'number' || typeof y !== 'number') return null; return x * y; }
        },
        jsLogic: `async function(inputs) { const x = inputs["x"]; const y = inputs["y"]; if (typeof x !== 'number' || typeof y !== 'number') return null; return x * y; }`,
        pyLogic: `def compute_multiply(inputs):\n    x = inputs.get("x")\n    y = inputs.get("y")\n    if isinstance(x, (int, float)) and isinstance(y, (int, float)):\n        return x * y\n    return None`,
        pyImports: [],
    },
    DivideNode: {
        definition: {
            title: "Divide",
            inputs: ["a", "b"],
            outputs: ["quotient"],
            renderContent() { return `<div class="node-content" style="padding:10px; font-size:0.9rem;">Divides a by b.</div>`; },
            compute(inputs) { const a = inputs["a"]; const b = inputs["b"]; if (typeof a !== 'number' || typeof b !== 'number' || b === 0) return null; return a / b; }
        },
        jsLogic: `async function(inputs) { const a = inputs["a"]; const b = inputs["b"]; if (typeof a !== 'number' || typeof b !== 'number' || b === 0) return null; return a / b; }`,
        pyLogic: `def compute_divide(inputs):\n    a = inputs.get("a")\n    b = inputs.get("b")\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)) and b != 0:\n        return a / b\n    return None`,
        pyImports: [],
    },
    PrintNode: {
      definition: {
          title: "Print to Console",
          inputs: ["input"],
          outputs: [],
          renderContent(node) { return `<div class="node-content" style="padding:10px; font-size:0.9rem; color: #8a8;">(Logs to console)</div>`; }
      },
      jsLogic: null,
      pyLogic: null,
      pyImports: [],
    },
    OutputNode: {
      definition: {
          title: "Output",
          inputs: ["input"],
          outputs: [],
          renderContent(node) {
              return `
                  <div class="node-content-display" style="padding:10px; font-size:0.9rem; min-height: 20px; word-break: break-all;"></div>
                  <iframe class="output-iframe" id="iframe-${node.id}" style="display:none;" sandbox></iframe>
              `;
          }
      },
      jsLogic: null, 
      pyLogic: null,
      pyImports: [],
    }
  };


  const app = {
    nodes: [],
    connections: [],
    nextNodeId: 1,
    draggedNode: null,
    dragOffsetX: 0,
    dragOffsetY: 0,
    connecting: null,
    contextMenuNodeId: null,
    canvasScale: 1,
    canvasTranslateX: 0,
    canvasTranslateY: 0,
    isPanning: false,
    lastPanX: 0,
    lastPanY: 0,
  };
  
  // Provide a global context for external nodes to access core app functionality.
  window.AGGM_APP_CONTEXT = {
      app: app,
      get onConnectorClick() { return onConnectorClick; },
      get redrawAllConnections() { return redrawAllConnections; },
      get saveStateToLocalStorage() { return saveStateToLocalStorage; }
  };

  const canvas = document.getElementById('canvas');
  const canvasContentWrapper = document.getElementById('canvas-content-wrapper');
  const nodeList = document.getElementById('node-list');
  const connectionsSvg = document.getElementById('connections');
  const runBtn = document.getElementById('run-btn');
  const exportProjectBtn = document.getElementById('export-project-btn');
  const importNodesBtn = document.getElementById('import-nodes-btn');
  const importNodesFile = document.getElementById('import-nodes-file');
  const contextMenu = document.getElementById('context-menu');
  const searchNodesInput = document.getElementById('search-nodes');
  const projectNameInput = document.getElementById('project-name-input');
  const clearWorkspaceBtn = document.getElementById('clear-workspace-btn');
  const nodeCounter = document.getElementById('node-counter');

  function registerNodes() {
    for (const typeKey in BUILTIN_NODE_DEFINITIONS) {
        const nodeDef = BUILTIN_NODE_DEFINITIONS[typeKey];
        nodeTypes[typeKey] = nodeDef.definition;
        nodeTypes[typeKey].jsLogic = nodeDef.jsLogic;
        nodeTypes[typeKey].pyLogic = nodeDef.pyLogic;
        nodeTypes[typeKey].pyImports = nodeDef.pyImports;
    }

    if (window.AGGM_CUSTOM_NODES) {
        console.log("Loading custom nodes...");
        for (const typeKey in window.AGGM_CUSTOM_NODES) {
            const customNode = window.AGGM_CUSTOM_NODES[typeKey];
            nodeTypes[typeKey] = customNode.definition;
            nodeTypes[typeKey].jsLogic = customNode.jsLogic;
            nodeTypes[typeKey].pyLogic = customNode.pyLogic;
            nodeTypes[typeKey].pyImports = customNode.pyImports || [];
        }
    } else {
        console.log("No custom nodes file found or file is empty.");
    }
  }

  function updateNodeCounter() {
    const count = app.nodes.length;
    nodeCounter.textContent = `Nodes: ${count}`;
  }

  function saveStateToLocalStorage() {
      const state = {
        projectName: projectNameInput.value,
        graph: exportGraphData(),
        transform: {
            scale: app.canvasScale,
            translateX: app.canvasTranslateX,
            translateY: app.canvasTranslateY
        },
        nextNodeId: app.nextNodeId
      };
      localStorage.setItem('aggmNodesProject', JSON.stringify(state));
  }

  function loadStateFromLocalStorage() {
    const savedStateJSON = localStorage.getItem('aggmNodesProject');
    if (!savedStateJSON) return;

    try {
        const savedState = JSON.parse(savedStateJSON);

        clearWorkbench(false); 

        projectNameInput.value = savedState.projectName || 'My Project';
        app.nodes = savedState.graph.nodes || [];
        app.connections = savedState.graph.connections || [];
        app.nextNodeId = savedState.nextNodeId || Math.max(0, ...app.nodes.map(n => n.id)) + 1;
        
        if (savedState.transform) {
            app.canvasScale = savedState.transform.scale || 1;
            app.canvasTranslateX = savedState.transform.translateX || 0;
            app.canvasTranslateY = savedState.transform.translateY || 0;
        }

        app.nodes.forEach(node => renderNode(node));
        updateCanvasTransform();
        updateNodeCounter();
        
    } catch (error) {
        console.error("Failed to load saved state:", error);
        localStorage.removeItem('aggmNodesProject'); 
    }
  }

  function createNode(typeKey, x, y, id) {
    const type = nodeTypes[typeKey];
    if (!type) return;
    
    let initialX, initialY;
    if (x === undefined || y === undefined) {
        const canvasRect = canvas.getBoundingClientRect();
        const viewCenterX = canvasRect.width / 2;
        const viewCenterY = canvasRect.height / 2;
        initialX = (viewCenterX - app.canvasTranslateX) / app.canvasScale;
        initialY = (viewCenterY - app.canvasTranslateY) / app.canvasScale;
    } else {
        initialX = x;
        initialY = y;
    }

    const node = {
      id: id || app.nextNodeId++,
      type: typeKey,
      x: initialX,
      y: initialY,
      dom: null,
      value: undefined
    };
    if (type.defaultValue) {
      node.value = JSON.parse(JSON.stringify(type.defaultValue));
    }

    if (!id) {
        app.nodes.push(node);
    }
    renderNode(node);
    updateNodeCounter();
    if (!id) {
        saveStateToLocalStorage();
    }
  }

  function renderNode(node) {
    const type = nodeTypes[node.type];
    const nodeEl = document.createElement('div');
    nodeEl.classList.add('node');
    nodeEl.style.left = node.x + 'px';
    nodeEl.style.top = node.y + 'px';
    nodeEl.dataset.id = node.id;

    const outputsArray = typeof type.outputs === 'function' ? type.outputs(node) : type.outputs;

    nodeEl.innerHTML = `
      <div class="node-header">${type.title}</div>
      <div class="node-io">
        <div class="inputs">
          ${type.inputs.map(name => `
            <div class="io-item">
              <div class="io-connector input" data-nodeid="${node.id}" data-type="input" data-name="${name}" title="Input: ${name}"></div>
              <span style="margin-left:8px;">${name}</span>
            </div>`).join('')}
        </div>
        <div class="outputs">
          ${outputsArray.map(name => `
            <div class="io-item" style="justify-content:flex-end;">
              <span style="margin-right:8px;">${name}</span>
              <div class="io-connector output" data-nodeid="${node.id}" data-type="output" data-name="${name}" title="Output: ${name}"></div>
            </div>`).join('')}
        </div>
      </div>
      ${type.renderContent ? type.renderContent(node) : ''}
    `;
    
    canvasContentWrapper.appendChild(nodeEl);
    node.dom = nodeEl;

    if (type.setupEventListeners) {
        type.setupEventListeners(node);
    }

    nodeEl.querySelectorAll('input, textarea, select').forEach(input => {
        input.addEventListener('input', () => {
            if (type.update) type.update(node);
            saveStateToLocalStorage();
        });
        input.addEventListener('mousedown', e => e.stopPropagation());
    });

    nodeEl.querySelector('.node-header').addEventListener('mousedown', onNodeDragStart);
    nodeEl.querySelectorAll('.io-connector').forEach(connector => {
      connector.addEventListener('mousedown', onConnectorClick);
    });
  }
  
  function updateCanvasTransform() {
      const transform = `translate(${app.canvasTranslateX}px, ${app.canvasTranslateY}px) scale(${app.canvasScale})`;
      canvasContentWrapper.style.transform = transform;
      connectionsSvg.style.transform = transform;
      redrawAllConnections();
  }

  function updateNodePosition(node, x, y) {
    node.x = x;
    node.y = y;
    node.dom.style.left = x + 'px';
    node.dom.style.top = y + 'px';
    updateConnectionsForNode(node.id);
  }

  function getConnectorPosition(nodeId, ioType, ioName) {
    const node = app.nodes.find(n => n.id === nodeId);
    if (!node || !node.dom) return null;
    const el = node.dom.querySelector(`.io-connector.${ioType}[data-name="${ioName}"]`);
    if (!el) return null;
    
    const x = node.x + (el.offsetLeft + el.offsetWidth / 2);
    const y = node.y + (el.offsetTop + el.offsetHeight / 2);

    return { x, y };
  }

  function updateConnectionsForNode(nodeId) {
    connectionsSvg.querySelectorAll(`[data-from-nodeid="${nodeId}"], [data-to-nodeid="${nodeId}"]`).forEach(line => {
        const fromNodeId = Number(line.dataset.fromNodeid);
        const fromOutput = line.dataset.fromoutput;
        const toNodeId = Number(line.dataset.toNodeid);
        const toInput = line.dataset.toinput;

        const fromPos = getConnectorPosition(fromNodeId, 'output', fromOutput);
        const toPos = getConnectorPosition(toNodeId, 'input', toInput);
        if (fromPos && toPos) {
            line.setAttribute('x1', fromPos.x);
            line.setAttribute('y1', fromPos.y);
            line.setAttribute('x2', toPos.x);
            line.setAttribute('y2', toPos.y);
        }
    });
  }
  
  function redrawAllConnections() {
    connectionsSvg.innerHTML = '';
    
    for (const conn of app.connections) {
      const fromPos = getConnectorPosition(conn.fromNodeId, 'output', conn.fromOutput);
      const toPos = getConnectorPosition(conn.toNodeId, 'input', conn.toInput);
      if (fromPos && toPos) {
        const line = createSVGLine(fromPos.x, fromPos.y, toPos.x, toPos.y);
        line.dataset.fromNodeid = conn.fromNodeId;
        line.dataset.fromoutput = conn.fromOutput;
        line.dataset.toNodeid = conn.toNodeId;
        line.dataset.toinput = conn.toInput;
      }
    }
  }

  function startConnecting(startNodeId, startIoName, startIoType) {
    const startPos = getConnectorPosition(startNodeId, startIoType, startIoName);
    if (!startPos) return;

    const tempLine = createSVGLine(startPos.x, startPos.y, startPos.x, startPos.y);
    tempLine.style.pointerEvents = 'none';

    app.connecting = { startNodeId, startIoName, startIoType, tempLine };
    
    window.addEventListener('mousemove', onConnectionDrag);
    window.addEventListener('mouseup', onConnectionEnd, { once: true });
  }

  function cancelConnecting() {
    if (!app.connecting) return;
    if (app.connecting.tempLine.parentNode) {
        app.connecting.tempLine.parentNode.removeChild(app.connecting.tempLine);
    }
    app.connecting = null;
    window.removeEventListener('mousemove', onConnectionDrag);
  }

  function deleteNode(nodeId) {
    app.nodes = app.nodes.filter(node => node.id !== nodeId);
    app.connections = app.connections.filter(conn => 
      conn.fromNodeId !== nodeId && conn.toNodeId !== nodeId
    );
    const nodeEl = canvasContentWrapper.querySelector(`.node[data-id="${nodeId}"]`);
    if (nodeEl) {
      nodeEl.remove();
    }
    redrawAllConnections();
    updateNodeCounter();
    saveStateToLocalStorage();
  }

  function duplicateNode(nodeId) {
    const originalNode = app.nodes.find(n => n.id === nodeId);
    if (!originalNode) return;

    const type = nodeTypes[originalNode.type];
    if (type && type.update) {
        type.update(originalNode);
    }

    const newNodeX = originalNode.x + 30;
    const newNodeY = originalNode.y + 30;

    const newNode = {
      id: app.nextNodeId++,
      type: originalNode.type,
      x: newNodeX,
      y: newNodeY,
      dom: null,
      value: originalNode.value !== undefined ? JSON.parse(JSON.stringify(originalNode.value)) : undefined,
      outputCount: originalNode.outputCount
    };

    app.nodes.push(newNode);
    renderNode(newNode);
    updateNodeCounter();
    saveStateToLocalStorage();
  }

  function clearWorkbench(confirmFirst = true) {
    if (confirmFirst) {
        if (!confirm("Are you sure you want to clear the entire workspace? This cannot be undone.")) {
            return;
        }
    }
    app.nodes = [];
    app.connections = [];
    app.nextNodeId = 1;
    projectNameInput.value = "My Project";
    canvasContentWrapper.innerHTML = '';
    connectionsSvg.innerHTML = '';
    app.canvasScale = 1;
    app.canvasTranslateX = 0;
    app.canvasTranslateY = 0;
    updateCanvasTransform();
    updateNodeCounter();
    if (confirmFirst) {
        localStorage.removeItem('aggmNodesProject');
    }
  }

  function onNodeDragStart(e) {
    if (e.button !== 0) return;
    if (e.target.closest('.io-connector, .node-input, .splitter-range, input, textarea, select')) return;
    e.preventDefault();
    const nodeId = parseInt(e.target.closest('.node').dataset.id);
    const node = app.nodes.find(n => n.id === nodeId);
    if (!node) return;

    app.draggedNode = node;
    
    const nodeScreenX = node.x * app.canvasScale + app.canvasTranslateX;
    const nodeScreenY = node.y * app.canvasScale + app.canvasTranslateY;

    app.dragOffsetX = e.clientX - nodeScreenX;
    app.dragOffsetY = e.clientY - nodeScreenY;

    node.dom.classList.add('dragging');
    window.addEventListener('mousemove', onNodeDrag);
    window.addEventListener('mouseup', onNodeDragEnd, { once: true });
  }

  function onNodeDrag(e) {
    if (!app.draggedNode) return;
    e.preventDefault();

    const newX = (e.clientX - app.dragOffsetX - app.canvasTranslateX) / app.canvasScale;
    const newY = (e.clientY - app.dragOffsetY - app.canvasTranslateY) / app.canvasScale;

    updateNodePosition(app.draggedNode, newX, newY);
  }

  function onNodeDragEnd() {
    if (app.draggedNode) {
      app.draggedNode.dom.classList.remove('dragging');
      saveStateToLocalStorage();
    }
    app.draggedNode = null;
    window.removeEventListener('mousemove', onNodeDrag);
  }
  
  function onConnectorClick(e) {
    e.stopPropagation();
    const { nodeid, type, name } = e.target.dataset;
    const clickedNodeId = parseInt(nodeid);

    if (app.connecting) {
        const { startNodeId, startIoType } = app.connecting;

        if (clickedNodeId === startNodeId || type === startIoType) {
            cancelConnecting();
            return;
        }

        const from = startIoType === 'output'
            ? { nodeId: startNodeId, ioName: app.connecting.startIoName }
            : { nodeId: clickedNodeId, ioName: name };
        const to = startIoType === 'input'
            ? { nodeId: startNodeId, ioName: app.connecting.startIoName }
            : { nodeId: clickedNodeId, ioName: name };

        if (app.connections.some(c => c.toNodeId === to.nodeId && c.toInput === to.ioName)) {
            cancelConnecting();
            return;
        }

        app.connections.push({
            fromNodeId: from.nodeId,
            fromOutput: from.ioName,
            toNodeId: to.nodeId,
            toInput: to.ioName
        });

        cancelConnecting();
        redrawAllConnections();
        saveStateToLocalStorage();

    } else {
        startConnecting(clickedNodeId, name, type);
    }
}

  function onConnectionDrag(e) {
    if (!app.connecting) return;
    e.preventDefault();
    
    const svgRect = connectionsSvg.getBoundingClientRect();

    const x = (e.clientX - svgRect.left) / app.canvasScale;
    const y = (e.clientY - svgRect.top) / app.canvasScale;

    app.connecting.tempLine.setAttribute('x2', x);
    app.connecting.tempLine.setAttribute('y2', y);
  }
  
  function onConnectionEnd(e) {
    if (app.connecting && !e.target.closest('.io-connector')) {
        cancelConnecting();
    }
  }

  function onContextMenuClick(e) {
    const action = e.target.dataset.action;
    if (app.contextMenuNodeId && action) {
      if (action === 'delete') {
        deleteNode(app.contextMenuNodeId);
      } else if (action === 'duplicate') {
        duplicateNode(app.contextMenuNodeId);
      }
    }
    hideContextMenu();
  }

  function hideContextMenu() {
    contextMenu.style.display = 'none';
    app.contextMenuNodeId = null;
  }
  
  function onCanvasMouseDown(e) {
    const clickedNodeEl = e.target.closest('.node');

    if (e.button === 2 || e.ctrlKey) { 
        e.preventDefault();
        if (clickedNodeEl) {
            app.contextMenuNodeId = parseInt(clickedNodeEl.dataset.id);
            contextMenu.style.left = `${e.clientX}px`;
            contextMenu.style.top = `${e.clientY}px`;
            contextMenu.style.display = 'block';
        } else {
            app.isPanning = true;
            app.lastPanX = e.clientX;
            app.lastPanY = e.clientY;
            canvas.style.cursor = 'grabbing';
            window.addEventListener('mousemove', onCanvasPan);
            window.addEventListener('mouseup', onCanvasPanEnd, { once: true });
        }
    } else if (e.button === 0) { 
        if (!clickedNodeEl && !contextMenu.contains(e.target)) {
            hideContextMenu();
        }
    }
  }

  function onCanvasPan(e) {
      if (!app.isPanning) return;
      e.preventDefault();
      const dx = e.clientX - app.lastPanX;
      const dy = e.clientY - app.lastPanY;

      app.canvasTranslateX += dx;
      app.canvasTranslateY += dy;
      
      app.lastPanX = e.clientX;
      app.lastPanY = e.clientY;
      
      updateCanvasTransform();
  }
  
  function onCanvasPanEnd() {
      app.isPanning = false;
      canvas.style.cursor = 'default';
      window.removeEventListener('mousemove', onCanvasPan);
      saveStateToLocalStorage();
  }

  function onCanvasWheel(e) {
      e.preventDefault();
      const zoomIntensity = 0.05; 
      const minScale = 0.2;
      const maxScale = 2.5;
      
      const delta = e.deltaY > 0 ? -1 : 1;
      
      const oldScale = app.canvasScale;
      const newScale = Math.max(minScale, Math.min(maxScale, oldScale + delta * zoomIntensity));

      const canvasRect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - canvasRect.left;
      const mouseY = e.clientY - canvasRect.top;

      app.canvasTranslateX = mouseX - (mouseX - app.canvasTranslateX) * (newScale / oldScale);
      app.canvasTranslateY = mouseY - (mouseY - app.canvasTranslateY) * (newScale / oldScale);
      app.canvasScale = newScale;
      
      updateCanvasTransform();
      saveStateToLocalStorage();
  }

  async function evaluateNodeOutput(nodeId, outputName, visited = new Set()) {
    const visitedKey = `${nodeId}-${outputName}`;
    if (visited.has(visitedKey)) {
        console.warn("Circular dependency detected at node", nodeId);
        return null;
    }
    visited.add(visitedKey);
    const node = app.nodes.find(n => n.id === nodeId);
    if (!node) return null;
    const type = nodeTypes[node.type];
    
    if (type.update) {
      type.update(node);
    }

    if (type.getOutput) {
      return type.getOutput.call(node, outputName);
    }
    if (type.compute) {
      const inputs = {};
      const requiredInputs = typeof type.inputs === 'function' ? type.inputs(node) : type.inputs;
      
      for (const inputName of requiredInputs) {
        const conn = app.connections.find(c => c.toNodeId === nodeId && c.toInput === inputName);
        if (!conn) {
          inputs[inputName] = null;
          continue;
        }
        inputs[inputName] = await evaluateNodeOutput(conn.fromNodeId, conn.fromOutput, new Set(visited));
      }
      return await type.compute.call(node, inputs);
    }
    return null;
  }

  async function runGraph() {
    const terminalNodes = app.nodes.filter(n => n.type === 'OutputNode' || n.type === 'PrintNode');
    if (terminalNodes.length === 0) {
      alert("No Output or Print Node found! Add one to see results.");
      return;
    }
    
    app.nodes.forEach(node => {
        if (node.type === 'OutputNode') {
            const contentDiv = node.dom.querySelector('.node-content-display');
            if(contentDiv) contentDiv.textContent = 'Calculating...';
            const iframe = node.dom.querySelector('.output-iframe');
            if(iframe) iframe.style.display = 'none';
        }
    });

    for (const termNode of terminalNodes) {
      const conn = app.connections.find(c => c.toNodeId === termNode.id && c.toInput === "input");
      let result = null;
      if (conn) {
        result = await evaluateNodeOutput(conn.fromNodeId, conn.fromOutput);
      }
      
      if (termNode.type === 'PrintNode') {
          console.log(`Print Node ${termNode.id}:`, result);
          const contentDiv = termNode.dom.querySelector('.node-content');
          if(contentDiv) contentDiv.textContent = `(Logged to console)`;
      } else { // OutputNode
            const contentDiv = termNode.dom.querySelector('.node-content-display');
            const iframe = termNode.dom.querySelector('.output-iframe');
            
            if (typeof result === 'string' && (result.trim().startsWith('<') && result.trim().endsWith('>'))) {
                contentDiv.style.display = 'none';
                iframe.style.display = 'block';
                iframe.srcdoc = `<html><head><style>body{font-family: sans-serif; color: #333;}</style></head><body>${result}</body></html>`;
            } else {
                contentDiv.style.display = 'block';
                iframe.style.display = 'none';
                contentDiv.textContent = result !== null ? JSON.stringify(result, null, 2) : 'null';
            }
      }
    }
  }

  function exportGraphData() {
    app.nodes.forEach(node => {
        const type = nodeTypes[node.type];
        if (type && type.update) {
            type.update(node);
        }
    });

    return {
      nodes: app.nodes.map(node => {
        const { dom, ...rest } = node;
        return { ...rest };
      }),
      connections: app.connections
    };
  }
  
  function generateJsCode(graphData, projectName) {
    const usedNodeTypes = [...new Set(graphData.nodes.map(n => n.type))];
    let runtimeLogic = '';

    usedNodeTypes.forEach(typeKey => {
        const typeDef = nodeTypes[typeKey];
        if (!typeDef || !typeDef.jsLogic) return;
        
        let logicString = typeDef.jsLogic;
        
        runtimeLogic += `        "${typeKey}": {\n`;
        if (typeDef.getOutput) {
            runtimeLogic += `            getOutput: ${logicString}`;
        } else if (typeDef.compute) {
            runtimeLogic += `            compute: ${logicString},\n`;
            const inputs = typeof typeDef.inputs === 'function' ? typeDef.inputs({ outputCount: 2 }) : typeDef.inputs;
            runtimeLogic += `            inputs: ${JSON.stringify(inputs)}`;
        }
        runtimeLogic += `\n        },\n`;
    });
    
    return `
// Project: ${projectName}
// Created using Adolfo GM's Node Graph Editor
// This is a self-contained, runnable client-side script.

(async () => {
    const nodeGraph = ${JSON.stringify(graphData, null, 2)};

    const runtimeNodeTypes = {
${runtimeLogic}
        PrintNode: { inputs: ["input"] },
        OutputNode: { inputs: ["input"] }
    };

    const evaluatedOutputs = new Map();

    async function evaluateNodeOutput(nodeId, outputName, visited = new Set()) {
        const visitedKey = \`\${nodeId}-\${outputName}\`;
        if (evaluatedOutputs.has(visitedKey)) {
            return evaluatedOutputs.get(visitedKey);
        }
        if (visited.has(visitedKey)) {
            console.warn("Circular dependency detected at node", nodeId);
            return null;
        }
        visited.add(visitedKey);

        const node = nodeGraph.nodes.find(n => n.id === nodeId);
        if (!node) return null;

        const type = runtimeNodeTypes[node.type];
        if (!type) {
            console.error(\`Unknown node type: \${node.type}\`);
            return null;
        }
        
        let result = null;
        if (type.getOutput) {
            result = type.getOutput.call(node, outputName);
        } else if (type.compute) {
            const inputs = {};
            const requiredInputs = type.inputs || [];

            for (const inputName of requiredInputs) {
                const conn = nodeGraph.connections.find(c => c.toNodeId === nodeId && c.toInput === inputName);
                if (!conn) {
                    inputs[inputName] = null;
                    continue;
                }
                inputs[inputName] = await evaluateNodeOutput(conn.fromNodeId, conn.fromOutput, new Set(visited));
            }
            result = await type.compute.call(node, inputs);
        }
        
        evaluatedOutputs.set(visitedKey, result);
        return result;
    }

    async function run() {
        console.log("Running graph: ${projectName}");
        const terminalNodes = nodeGraph.nodes.filter(n => n.type === 'OutputNode' || n.type === 'PrintNode');

        if (terminalNodes.length === 0) {
            console.log("No Output or Print Nodes found in the graph.");
            return;
        }

        for (const termNode of terminalNodes) {
            const conn = nodeGraph.connections.find(c => c.toNodeId === termNode.id && c.toInput === "input");
            let result = null;
            if (conn) {
                result = await evaluateNodeOutput(conn.fromNodeId, conn.fromOutput);
            }
            
            if (termNode.type === 'PrintNode') {
                console.log(\`▶ Print Node \${termNode.id}:\`, result);
            } else {
                console.log(\`▶ Result for Output Node \${termNode.id}:\`, result);
            }
        }
    }

    await run();

})();`;
  }

  function generatePythonCode(graphData, projectName) {
    const usedNodeTypes = [...new Set(graphData.nodes.map(n => n.type))];
    let pythonFunctions = '';
    let nodeLogicDict = '';
    const allPyImports = new Set(['json', 'math', 'random']);
    
    usedNodeTypes.forEach((typeKey) => {
        const typeDef = nodeTypes[typeKey];
        if (!typeDef || !typeDef.pyLogic) return;

        if (typeDef.pyImports && typeDef.pyImports.length > 0) {
            typeDef.pyImports.forEach(imp => allPyImports.add(imp));
        }
        
        let logicString = typeDef.pyLogic;
        let pyFuncName = logicString.split(' ')[1].split('(')[0];
        
        pythonFunctions += `${logicString}\n\n`;

        nodeLogicDict += `    "${typeKey}": {`;
        if (typeDef.getOutput) {
            nodeLogicDict += `"get_output": ${pyFuncName}`;
        } else if (typeDef.compute) {
            nodeLogicDict += `"compute": ${pyFuncName}, `;
            const inputs = typeof typeDef.inputs === 'function' ? typeDef.inputs({ outputCount: 2 }) : typeDef.inputs;
            nodeLogicDict += `"inputs": ${JSON.stringify(inputs)}`;
        }
        nodeLogicDict += `},\n`;
    });

    const importStatements = [...allPyImports].map(imp => imp.startsWith('from') ? imp : `import ${imp}`).join('\n');
    
    return `
# Project: ${projectName}
# Created using Adolfo GM's Node Graph Editor
# This is a self-contained, runnable Python script.
# NOTE: Some nodes may require non-standard libraries (e.g., 'requests').

${importStatements}

# --- Project and Graph Data ---
projectName = "${projectName}"
node_graph = ${JSON.stringify(graphData, null, 2)}

# --- Node Logic Definitions ---
${pythonFunctions}

node_logic = {
${nodeLogicDict}
    "PrintNode": {"inputs": ["input"]},
    "OutputNode": {"inputs": ["input"]}
}

# --- Execution Engine ---
evaluated_outputs = {}

def find_node_by_id(node_id):
    for node in node_graph["nodes"]:
        if node["id"] == node_id:
            return node
    return None

def evaluate_node_output(node_id, output_name, visited=None):
    if visited is None:
        visited = set()
    
    visited_key = f"{node_id}-{output_name}"
    if visited_key in evaluated_outputs:
        return evaluated_outputs[visited_key]
    
    if visited_key in visited:
        print(f"Warning: Circular dependency detected at node {node_id}")
        return None
    
    visited.add(visited_key)

    node = find_node_by_id(node_id)
    if not node:
        return None

    node_type = node["type"]
    logic = node_logic.get(node_type)
    if not logic:
        print(f"Error: Unknown node type '{node_type}'")
        return None

    result = None
    if "get_output" in logic:
        result = logic["get_output"](node)
    elif "compute" in logic:
        inputs = {}
        required_inputs = logic.get("inputs", [])
        
        for input_name in required_inputs:
            conn = next((c for c in node_graph["connections"] if c["toNodeId"] == node_id and c["toInput"] == input_name), None)
            
            if not conn:
                inputs[input_name] = None
                continue

            inputs[input_name] = evaluate_node_output(conn["fromNodeId"], conn["fromOutput"], visited.copy())
        
        if node_type == 'AskPollinationsNode':
             result = logic["compute"](inputs, node)
        else:
             result = logic["compute"](inputs)

    evaluated_outputs[visited_key] = result
    return result

def main():
    print(f"Running graph: {projectName}")
    terminal_nodes = [n for n in node_graph["nodes"] if n["type"] in ("OutputNode", "PrintNode")]

    if not terminal_nodes:
        print("No Output or Print Nodes found in the graph.")
        return

    for term_node in terminal_nodes:
        conn = next((c for c in node_graph["connections"] if c["toNodeId"] == term_node["id"] and c["toInput"] == "input"), None)
        result = None
        if conn:
            result = evaluate_node_output(conn["fromNodeId"], conn["fromOutput"])
        
        if term_node["type"] == "PrintNode":
            print(f"▶ Print Node {term_node['id']}:")
            print(result)
        else:
            print(f"▶ Result for Output Node {term_node['id']}:")
            try:
                print(json.dumps(result, indent=2))
            except TypeError:
                print(result)

if __name__ == "__main__":
    main()
`;
  }
  
  function downloadFile(content, filename, contentType) {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function exportProjectToZip() {
    if (typeof JSZip === 'undefined') {
        alert('JSZip library not loaded. Cannot create zip file.');
        return;
    }
    
    const projectName = projectNameInput.value.trim().replace(/\s+/g, '_') || 'UntitledProject';
    const dateStr = new Date().toISOString().slice(0, 10);
    const zipFilename = `${projectName}_${dateStr}.zip`;

    const graphData = exportGraphData();
    const jsCode = generateJsCode(graphData, projectName);
    const pythonCode = generatePythonCode(graphData, projectName);

    const zip = new JSZip();
    const folder = zip.folder(projectName);
    folder.file(`${projectName}.js`, jsCode);
    folder.file(`${projectName}.py`, pythonCode);

    try {
        const blob = await zip.generateAsync({ type: "blob" });
        downloadFile(blob, zipFilename, 'application/zip');
    } catch(error) {
        console.error("Failed to generate zip file:", error);
        alert("An error occurred while creating the zip file.");
    }
  }

  function importNodes() {
    importNodesFile.click();
  }

  function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
      try {
        const fileContent = e.target.result;
        let importedGraph;

        const jsonMatch = fileContent.match(/=\s*(\{[\s\S]*?\});?\s*(\n|$)/);

        if (jsonMatch && jsonMatch[1]) {
            try {
               importedGraph = JSON.parse(jsonMatch[1]);
            } catch(e) {
               throw new Error("Could not parse the JSON object from the script file.");
            }
        } else {
             try {
                importedGraph = JSON.parse(fileContent);
             } catch(jsonError) {
                 throw new Error("File is not a valid graph JSON or a runnable JS/Python export.");
             }
        }
        
        if (!importedGraph.nodes || !importedGraph.connections) {
            throw new Error("Parsed object is not a valid graph structure.");
        }

        clearWorkbench(false); 

        app.nodes = importedGraph.nodes || [];
        app.connections = importedGraph.connections || [];
        app.nextNodeId = Math.max(0, ...app.nodes.map(n => n.id)) + 1;

        app.nodes.forEach(node => {
            const type = nodeTypes[node.type];
            if(type.update) type.update(node);
        });

        app.nodes.forEach(node => renderNode(node));
        redrawAllConnections();
        updateCanvasTransform();
        updateNodeCounter();
        saveStateToLocalStorage();
        console.log("Nodes imported successfully!");

      } catch (error) {
        console.error("Error importing nodes:", error);
        alert("Failed to import nodes: " + error.message);
      }
    };
    reader.readAsText(file);
    importNodesFile.value = '';
  }

  function createSVGLine(x1, y1, x2, y2) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("stroke", "var(--connector-color)");
    line.setAttribute("stroke-width", `${2 / app.canvasScale}`);
    line.setAttribute("stroke-linecap", "round");
    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);
    connectionsSvg.appendChild(line);
    return line;
  }

  function renderSidebar(filter = '') {
    nodeList.innerHTML = '';
    const lowerCaseFilter = filter.toLowerCase();
    
    const sortedNodeTypes = Object.entries(nodeTypes).sort((a, b) => a[1].title.localeCompare(b[1].title));

    sortedNodeTypes.forEach(([key, type]) => {
      if (type.title.toLowerCase().includes(lowerCaseFilter)) {
        const el = document.createElement('div');
        el.classList.add('node-type');
        el.textContent = type.title;
        el.title = `Add ${type.title}`;
        el.onclick = () => createNode(key);
        nodeList.appendChild(el);
      }
    });
  }
  
  function initialize() {
    registerNodes();
    renderSidebar();

    runBtn.onclick = runGraph;
    exportProjectBtn.onclick = exportProjectToZip;
    importNodesBtn.onclick = importNodes;
    importNodesFile.addEventListener('change', handleFileImport);
    clearWorkspaceBtn.onclick = () => clearWorkbench(true);
    projectNameInput.addEventListener('input', saveStateToLocalStorage);

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    canvas.addEventListener('mousedown', onCanvasMouseDown);
    canvas.addEventListener('wheel', onCanvasWheel, { passive: false });

    contextMenu.addEventListener('click', onContextMenuClick);
    window.addEventListener('mousedown', (e) => {
      if (!contextMenu.contains(e.target) && !e.target.closest('.node')) {
        hideContextMenu();
      }
    });

    searchNodesInput.addEventListener('input', (e) => {
      renderSidebar(e.target.value);
    });

    loadStateFromLocalStorage();
    updateNodeCounter();
  }

  initialize();
});
</script>

</body>
</html>
